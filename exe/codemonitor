#!/usr/bin/env ruby
# frozen_string_literal: true

require_relative '../providers/console'
require_relative '../providers/datadog'

require_relative '../engines/custom/extractor'
require_relative '../engines/debug/extractor'
require_relative '../engines/eslint/extractor'
require_relative '../engines/git/extractor'
require_relative '../engines/github/extractor'
require_relative '../engines/jest-json-summary/extractor'
require_relative '../engines/knip/extractor'
require_relative '../engines/npm/extractor'
require_relative '../engines/packwerk/extractor'
require_relative '../engines/rubocop/extractor'
require_relative '../engines/scc/extractor'
require_relative '../engines/semgrep/extractor'
require_relative '../engines/simplecov-json-coverage/extractor'
require_relative '../engines/sorbet/extractor'

PROVIDERS = {
  console: Providers::Console,
  datadog: Providers::Datadog
}.freeze

EXTRACTORS = {
  custom: Engines::Custom::Extractor,
  debug: Engines::Debug::Extractor,
  eslint: Engines::Eslint::Extractor,
  git: Engines::Git::Extractor,
  github: Engines::Github::Extractor,
  jest_json_summary: Engines::JestJsonSummary::Extractor,
  knip: Engines::Knip::Extractor,
  npm: Engines::Npm::Extractor,
  packwerk: Engines::Packwerk::Extractor,
  rubocop: Engines::Rubocop::Extractor,
  scc: Engines::Scc::Extractor,
  semgrep: Engines::Semgrep::Extractor,
  simplecov_json_coverage: Engines::SimpleCovJsonCoverage::Extractor,
  sorbet: Engines::Sorbet::Extractor
}.freeze

# Parse command-line arguments
interactive_mode = ARGV.include?('--interactive')

config_provider = ENV['CODEMONITOR_PROVIDER'] || 'console'
config_extractors = ENV['CODEMONITOR_EXTRACTORS']

provider = PROVIDERS[config_provider.to_sym].new

puts '# process start'

if interactive_mode
  # Read from stdin until two consecutive empty lines
  lines = []
  empty_line_count = 0
  
  while empty_line_count < 2
    line = $stdin.gets
    break unless line
    
    line = line.chomp
    
    if line.empty?
      empty_line_count += 1
    else
      empty_line_count = 0
      lines << line
    end
  end
  
  # Join the lines and evaluate as a Ruby hash
  input_str = lines.join("\n")
  
  begin
    metrics = eval(input_str)
    raise "Input must be a Hash" unless metrics.is_a?(Hash)
    
    provider.emit(metrics)
  rescue SyntaxError, StandardError => e
    puts "Error parsing input: #{e.message}"
    exit 1
  end
else
  # Original behavior: run extractors
  extractors = if config_extractors
                 EXTRACTORS.slice(*config_extractors.split(',').map(&:to_sym)).values
               else
                 EXTRACTORS.values
               end

  # Run all the extractors and collect the data
  extractors
    .map(&:new)
    .map do |extractor|
      raise "Requirements not fullfiled in #{extractor.class.name}" unless extractor.requirements?

      extractor.call(provider)
    end
end

# Send all the data to the provider
provider.send

puts '# process end'
